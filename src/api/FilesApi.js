/**
 * VRChat API Documentation
 * ![VRChat API Banner](https://raw.githubusercontent.com/vrchatapi/vrchatapi.github.io/master/assets/apibanner.png)  # VRChat API Documentation This project is an [OPEN Open Source Project](https://openopensource.org)  Individuals making significant and valuable contributions are given commit-access to the project to contribute as they see fit. This project is more like an open wiki than a standard guarded open source project.  ## Disclaimer  This is the official response of the VRChat Team (from Tupper more specifically) on the usage of the VRChat API.  > **Use of the API using applications other than the approved methods (website, VRChat application) are not officially supported. You may use the API for your own application, but keep these guidelines in mind:** > * We do not provide documentation or support for the API. > * Do not make queries to the API more than once per 60 seconds. > * Abuse of the API may result in account termination. > * Access to API endpoints may break at any given time, with no warning.  As stated, this documentation was not created with the help of the official VRChat team. Therefore this documentation is not an official documentation of the VRChat API and may not be always up to date with the latest versions. If you find that a page or endpoint is not longer valid please create an issue and tell us so we can fix it.  ## Get in touch with us!  [https://discord.gg/qjZE9C9fkB#vrchat-api](https://discord.gg/qjZE9C9fkB)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: me@ruby.js.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import Error from '../model/Error';
import InlineObject3 from '../model/InlineObject3';
import InlineObject4 from '../model/InlineObject4';
import InlineResponse2004 from '../model/InlineResponse2004';
import InlineResponse2005 from '../model/InlineResponse2005';
import Success from '../model/Success';

/**
* Files service.
* @module api/FilesApi
* @version 1.0.0
*/
export default class FilesApi {

    /**
    * Constructs a new FilesApi. 
    * @alias module:api/FilesApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }



    /**
     * Create File
     * Creates a new File object
     * @param {Object} opts Optional parameters
     * @param {module:model/InlineObject3} opts.inlineObject3 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
     */
    createFileWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = opts['inlineObject3'];

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['apiKeyCookie', 'authCookie'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = File;
      return this.apiClient.callApi(
        '/file', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create File
     * Creates a new File object
     * @param {Object} opts Optional parameters
     * @param {module:model/InlineObject3} opts.inlineObject3 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
     */
    createFile(opts) {
      return this.createFileWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create File Version
     * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
     * @param {String} fileId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
     */
    createFileVersionWithHttpInfo(fileId) {
      let postBody = null;
      // verify the required parameter 'fileId' is set
      if (fileId === undefined || fileId === null) {
        throw new Error("Missing the required parameter 'fileId' when calling createFileVersion");
      }

      let pathParams = {
        'fileId': fileId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['apiKeyCookie', 'authCookie'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = File;
      return this.apiClient.callApi(
        '/file/{fileId}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create File Version
     * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
     * @param {String} fileId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
     */
    createFileVersion(fileId) {
      return this.createFileVersionWithHttpInfo(fileId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete File
     * Deletes a File object.
     * @param {String} fileId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Success} and HTTP response
     */
    deleteFileWithHttpInfo(fileId) {
      let postBody = null;
      // verify the required parameter 'fileId' is set
      if (fileId === undefined || fileId === null) {
        throw new Error("Missing the required parameter 'fileId' when calling deleteFile");
      }

      let pathParams = {
        'fileId': fileId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['apiKeyCookie', 'authCookie'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Success;
      return this.apiClient.callApi(
        '/file/{fileId}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete File
     * Deletes a File object.
     * @param {String} fileId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Success}
     */
    deleteFile(fileId) {
      return this.deleteFileWithHttpInfo(fileId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete File Version
     * Delete a specific version of a file. You can only delete the latest version.
     * @param {String} fileId 
     * @param {Number} versionId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
     */
    deleteFileVersionWithHttpInfo(fileId, versionId) {
      let postBody = null;
      // verify the required parameter 'fileId' is set
      if (fileId === undefined || fileId === null) {
        throw new Error("Missing the required parameter 'fileId' when calling deleteFileVersion");
      }
      // verify the required parameter 'versionId' is set
      if (versionId === undefined || versionId === null) {
        throw new Error("Missing the required parameter 'versionId' when calling deleteFileVersion");
      }

      let pathParams = {
        'fileId': fileId,
        'versionId': versionId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['apiKeyCookie', 'authCookie'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = File;
      return this.apiClient.callApi(
        '/file/{fileId}/{versionId}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete File Version
     * Delete a specific version of a file. You can only delete the latest version.
     * @param {String} fileId 
     * @param {Number} versionId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
     */
    deleteFileVersion(fileId, versionId) {
      return this.deleteFileVersionWithHttpInfo(fileId, versionId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Download File Version
     * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
     * @param {String} fileId 
     * @param {Number} versionId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    downloadFileVersionWithHttpInfo(fileId, versionId) {
      let postBody = null;
      // verify the required parameter 'fileId' is set
      if (fileId === undefined || fileId === null) {
        throw new Error("Missing the required parameter 'fileId' when calling downloadFileVersion");
      }
      // verify the required parameter 'versionId' is set
      if (versionId === undefined || versionId === null) {
        throw new Error("Missing the required parameter 'versionId' when calling downloadFileVersion");
      }

      let pathParams = {
        'fileId': fileId,
        'versionId': versionId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['apiKeyCookie', 'authCookie'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/file/{fileId}/{versionId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Download File Version
     * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
     * @param {String} fileId 
     * @param {Number} versionId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    downloadFileVersion(fileId, versionId) {
      return this.downloadFileVersionWithHttpInfo(fileId, versionId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Finish FileData Upload
     * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
     * @param {String} fileId 
     * @param {Number} versionId 
     * @param {module:model/String} fileType 
     * @param {Object} opts Optional parameters
     * @param {module:model/InlineObject4} opts.inlineObject4 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
     */
    finishFileDataUploadWithHttpInfo(fileId, versionId, fileType, opts) {
      opts = opts || {};
      let postBody = opts['inlineObject4'];
      // verify the required parameter 'fileId' is set
      if (fileId === undefined || fileId === null) {
        throw new Error("Missing the required parameter 'fileId' when calling finishFileDataUpload");
      }
      // verify the required parameter 'versionId' is set
      if (versionId === undefined || versionId === null) {
        throw new Error("Missing the required parameter 'versionId' when calling finishFileDataUpload");
      }
      // verify the required parameter 'fileType' is set
      if (fileType === undefined || fileType === null) {
        throw new Error("Missing the required parameter 'fileType' when calling finishFileDataUpload");
      }

      let pathParams = {
        'fileId': fileId,
        'versionId': versionId,
        'fileType': fileType
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['apiKeyCookie', 'authCookie'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = File;
      return this.apiClient.callApi(
        '/file/{fileId}/{versionId}/{fileType}/finish', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Finish FileData Upload
     * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
     * @param {String} fileId 
     * @param {Number} versionId 
     * @param {module:model/String} fileType 
     * @param {Object} opts Optional parameters
     * @param {module:model/InlineObject4} opts.inlineObject4 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
     */
    finishFileDataUpload(fileId, versionId, fileType, opts) {
      return this.finishFileDataUploadWithHttpInfo(fileId, versionId, fileType, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Show File
     * Shows general information about the \"File\" object. Each File can have several \"Version\"'s, and each Version can have multiple real files or \"Data\" blobs.
     * @param {String} fileId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
     */
    getFileWithHttpInfo(fileId) {
      let postBody = null;
      // verify the required parameter 'fileId' is set
      if (fileId === undefined || fileId === null) {
        throw new Error("Missing the required parameter 'fileId' when calling getFile");
      }

      let pathParams = {
        'fileId': fileId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['apiKeyCookie', 'authCookie'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = File;
      return this.apiClient.callApi(
        '/file/{fileId}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Show File
     * Shows general information about the \"File\" object. Each File can have several \"Version\"'s, and each Version can have multiple real files or \"Data\" blobs.
     * @param {String} fileId 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
     */
    getFile(fileId) {
      return this.getFileWithHttpInfo(fileId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Check FileData Upload Status
     * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
     * @param {String} fileId 
     * @param {Number} versionId 
     * @param {module:model/String} fileType 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2004} and HTTP response
     */
    getFileDataUploadStatusWithHttpInfo(fileId, versionId, fileType) {
      let postBody = null;
      // verify the required parameter 'fileId' is set
      if (fileId === undefined || fileId === null) {
        throw new Error("Missing the required parameter 'fileId' when calling getFileDataUploadStatus");
      }
      // verify the required parameter 'versionId' is set
      if (versionId === undefined || versionId === null) {
        throw new Error("Missing the required parameter 'versionId' when calling getFileDataUploadStatus");
      }
      // verify the required parameter 'fileType' is set
      if (fileType === undefined || fileType === null) {
        throw new Error("Missing the required parameter 'fileType' when calling getFileDataUploadStatus");
      }

      let pathParams = {
        'fileId': fileId,
        'versionId': versionId,
        'fileType': fileType
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['apiKeyCookie', 'authCookie'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2004;
      return this.apiClient.callApi(
        '/file/{fileId}/{versionId}/{fileType}/status', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Check FileData Upload Status
     * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
     * @param {String} fileId 
     * @param {Number} versionId 
     * @param {module:model/String} fileType 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2004}
     */
    getFileDataUploadStatus(fileId, versionId, fileType) {
      return this.getFileDataUploadStatusWithHttpInfo(fileId, versionId, fileType)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * List Files
     * Returns a list of files
     * @param {Object} opts Optional parameters
     * @param {String} opts.tag Tag, for example \"icon\" or \"gallery\", not included by default.
     * @param {String} opts.userId UserID, will always generate a 500 permission error.
     * @param {Number} opts.n The number of objects to return. (default to 60)
     * @param {Number} opts.offset A zero-based offset from the default object sorting from where search results start.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<File>} and HTTP response
     */
    getFilesWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'tag': opts['tag'],
        'userId': opts['userId'],
        'n': opts['n'],
        'offset': opts['offset']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['apiKeyCookie', 'authCookie'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [File];
      return this.apiClient.callApi(
        '/files', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * List Files
     * Returns a list of files
     * @param {Object} opts Optional parameters
     * @param {String} opts.tag Tag, for example \"icon\" or \"gallery\", not included by default.
     * @param {String} opts.userId UserID, will always generate a 500 permission error.
     * @param {Number} opts.n The number of objects to return. (default to 60)
     * @param {Number} opts.offset A zero-based offset from the default object sorting from where search results start.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<File>}
     */
    getFiles(opts) {
      return this.getFilesWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Start FileData Upload
     * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS's REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
     * @param {String} fileId 
     * @param {Number} versionId 
     * @param {module:model/String} fileType 
     * @param {Number} partNumber 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2005} and HTTP response
     */
    startFileDataUploadWithHttpInfo(fileId, versionId, fileType, partNumber) {
      let postBody = null;
      // verify the required parameter 'fileId' is set
      if (fileId === undefined || fileId === null) {
        throw new Error("Missing the required parameter 'fileId' when calling startFileDataUpload");
      }
      // verify the required parameter 'versionId' is set
      if (versionId === undefined || versionId === null) {
        throw new Error("Missing the required parameter 'versionId' when calling startFileDataUpload");
      }
      // verify the required parameter 'fileType' is set
      if (fileType === undefined || fileType === null) {
        throw new Error("Missing the required parameter 'fileType' when calling startFileDataUpload");
      }
      // verify the required parameter 'partNumber' is set
      if (partNumber === undefined || partNumber === null) {
        throw new Error("Missing the required parameter 'partNumber' when calling startFileDataUpload");
      }

      let pathParams = {
        'fileId': fileId,
        'versionId': versionId,
        'fileType': fileType
      };
      let queryParams = {
        'partNumber': partNumber
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['apiKeyCookie', 'authCookie'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2005;
      return this.apiClient.callApi(
        '/file/{fileId}/{versionId}/{fileType}/start', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Start FileData Upload
     * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS's REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
     * @param {String} fileId 
     * @param {Number} versionId 
     * @param {module:model/String} fileType 
     * @param {Number} partNumber 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2005}
     */
    startFileDataUpload(fileId, versionId, fileType, partNumber) {
      return this.startFileDataUploadWithHttpInfo(fileId, versionId, fileType, partNumber)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


}
